{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"async-tiff","text":"<p>Fast, low-level async TIFF and GeoTIFF reader for Python.</p> <p>This documentation is for the Python bindings. Refer here for the Rust crate documentation.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#reading-naip","title":"Reading NAIP","text":"<pre><code>from async_tiff import TIFF\nfrom async_tiff.store import S3Store\n\n# You'll also need to provide credentials to access a requester pays bucket\nstore = S3Store(\"naip-visualization\", region=\"us-west-2\", request_payer=True)\npath = \"ny/2022/60cm/rgb/40073/m_4007307_sw_18_060_20220803.tif\"\n\ntiff = await TIFF.open(path, store=store)\nprimary_ifd = tiff.ifds[0]\n\nprimary_ifd.geo_key_directory.citation\n# 'NAD83 / UTM zone 18N'\n\nprimary_ifd.geo_key_directory.projected_type\n# 26918\n# (EPSG code)\n\nprimary_ifd.sample_format\n# [&lt;SampleFormat.Uint: 1&gt;, &lt;SampleFormat.Uint: 1&gt;, &lt;SampleFormat.Uint: 1&gt;]\n\nprimary_ifd.bits_per_sample\n# [8, 8, 8]\n\ntile = await tiff.fetch_tile(0, 0, 4)\ndecoded_bytes = await tile.decode_async()\n\n# Use rasterio and matplotlib for visualization\nimport numpy as np\nfrom rasterio.plot import reshape_as_raster, show\n\n# Wrap the rust buffer into a numpy array\narr = np.frombuffer(decoded_bytes, np.uint8)\n\n# We first need to reshape the array into the *existing* \"image\" axes\narr = arr.reshape(512, 512, 3)\n\n# Then we need to reshape the \"image\" axes into \"raster\" axes\n# https://rasterio.readthedocs.io/en/stable/topics/image_processing.html\narr = reshape_as_raster(arr)\nshow(arr, adjust=True)\n</code></pre>"},{"location":"#reading-sentinel-2-l2a","title":"Reading Sentinel 2 L2A","text":"<pre><code>from async_tiff import TIFF\nfrom async_tiff.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/B04.tif\"\n\ntiff = await TIFF.open(path, store=store)\nprimary_ifd = tiff.ifds[0]\n# Text readable citation\nprimary_ifd.geo_key_directory.citation\n# EPSG code\nprimary_ifd.geo_key_directory.projected_type\n\nprimary_ifd.sample_format[0]\n# &lt;SampleFormat.Uint: 1&gt;\nprimary_ifd.bits_per_sample[0]\n# 16\n\ntile = await tiff.fetch_tile(0, 0, 0)\ndecoded_bytes = await tile.decode_async()\n</code></pre>"},{"location":"api/decoder/","title":"Decoder","text":""},{"location":"api/decoder/#async_tiff.Decoder","title":"async_tiff.Decoder","text":"<p>               Bases: <code>Protocol</code></p> <p>A custom Python-provided decompression algorithm.</p>"},{"location":"api/decoder/#async_tiff.Decoder.__call__","title":"__call__  <code>staticmethod</code>","text":"<pre><code>__call__(buffer: Buffer) -&gt; Buffer\n</code></pre> <p>A callback to decode compressed data.</p>"},{"location":"api/decoder/#async_tiff.DecoderRegistry","title":"async_tiff.DecoderRegistry","text":"<p>A registry holding multiple decoder methods.</p>"},{"location":"api/decoder/#async_tiff.DecoderRegistry.__init__","title":"__init__","text":"<pre><code>__init__(\n    custom_decoders: dict[CompressionMethod | int, Decoder] | None = None,\n) -&gt; None\n</code></pre> <p>Construct a new decoder registry.</p> <p>By default, pure-Rust decoders will be used for any recognized and supported compression types. Only the supplied decoders will override Rust-native decoders.</p> <p>Parameters:</p> <ul> <li> <code>custom_decoders</code>               (<code>dict[CompressionMethod | int, Decoder] | None</code>, default:                   <code>None</code> )           \u2013            <p>any custom decoder methods to use. This will be applied after (and override) any default provided Rust decoders. Defaults to None.</p> </li> </ul>"},{"location":"api/geo/","title":"Geospatial tags","text":""},{"location":"api/geo/#async_tiff.GeoKeyDirectory","title":"async_tiff.GeoKeyDirectory","text":""},{"location":"api/geo/#async_tiff.GeoKeyDirectory.citation","title":"citation  <code>property</code>","text":"<pre><code>citation: str | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_angular_unit_size","title":"geog_angular_unit_size  <code>property</code>","text":"<pre><code>geog_angular_unit_size: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_angular_units","title":"geog_angular_units  <code>property</code>","text":"<pre><code>geog_angular_units: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_azimuth_units","title":"geog_azimuth_units  <code>property</code>","text":"<pre><code>geog_azimuth_units: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_citation","title":"geog_citation  <code>property</code>","text":"<pre><code>geog_citation: str | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_ellipsoid","title":"geog_ellipsoid  <code>property</code>","text":"<pre><code>geog_ellipsoid: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_geodetic_datum","title":"geog_geodetic_datum  <code>property</code>","text":"<pre><code>geog_geodetic_datum: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_inv_flattening","title":"geog_inv_flattening  <code>property</code>","text":"<pre><code>geog_inv_flattening: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_linear_unit_size","title":"geog_linear_unit_size  <code>property</code>","text":"<pre><code>geog_linear_unit_size: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_linear_units","title":"geog_linear_units  <code>property</code>","text":"<pre><code>geog_linear_units: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_prime_meridian","title":"geog_prime_meridian  <code>property</code>","text":"<pre><code>geog_prime_meridian: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_prime_meridian_long","title":"geog_prime_meridian_long  <code>property</code>","text":"<pre><code>geog_prime_meridian_long: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_semi_major_axis","title":"geog_semi_major_axis  <code>property</code>","text":"<pre><code>geog_semi_major_axis: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geog_semi_minor_axis","title":"geog_semi_minor_axis  <code>property</code>","text":"<pre><code>geog_semi_minor_axis: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.geographic_type","title":"geographic_type  <code>property</code>","text":"<pre><code>geographic_type: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.model_type","title":"model_type  <code>property</code>","text":"<pre><code>model_type: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_azimuth_angle","title":"proj_azimuth_angle  <code>property</code>","text":"<pre><code>proj_azimuth_angle: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_center_easting","title":"proj_center_easting  <code>property</code>","text":"<pre><code>proj_center_easting: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_center_lat","title":"proj_center_lat  <code>property</code>","text":"<pre><code>proj_center_lat: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_center_long","title":"proj_center_long  <code>property</code>","text":"<pre><code>proj_center_long: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_center_northing","title":"proj_center_northing  <code>property</code>","text":"<pre><code>proj_center_northing: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_citation","title":"proj_citation  <code>property</code>","text":"<pre><code>proj_citation: str | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_coord_trans","title":"proj_coord_trans  <code>property</code>","text":"<pre><code>proj_coord_trans: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_easting","title":"proj_false_easting  <code>property</code>","text":"<pre><code>proj_false_easting: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_northing","title":"proj_false_northing  <code>property</code>","text":"<pre><code>proj_false_northing: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_origin_easting","title":"proj_false_origin_easting  <code>property</code>","text":"<pre><code>proj_false_origin_easting: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_origin_lat","title":"proj_false_origin_lat  <code>property</code>","text":"<pre><code>proj_false_origin_lat: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_origin_long","title":"proj_false_origin_long  <code>property</code>","text":"<pre><code>proj_false_origin_long: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_false_origin_northing","title":"proj_false_origin_northing  <code>property</code>","text":"<pre><code>proj_false_origin_northing: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_linear_unit_size","title":"proj_linear_unit_size  <code>property</code>","text":"<pre><code>proj_linear_unit_size: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_linear_units","title":"proj_linear_units  <code>property</code>","text":"<pre><code>proj_linear_units: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_nat_origin_lat","title":"proj_nat_origin_lat  <code>property</code>","text":"<pre><code>proj_nat_origin_lat: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_nat_origin_long","title":"proj_nat_origin_long  <code>property</code>","text":"<pre><code>proj_nat_origin_long: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_scale_at_center","title":"proj_scale_at_center  <code>property</code>","text":"<pre><code>proj_scale_at_center: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_scale_at_nat_origin","title":"proj_scale_at_nat_origin  <code>property</code>","text":"<pre><code>proj_scale_at_nat_origin: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_std_parallel1","title":"proj_std_parallel1  <code>property</code>","text":"<pre><code>proj_std_parallel1: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_std_parallel2","title":"proj_std_parallel2  <code>property</code>","text":"<pre><code>proj_std_parallel2: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.proj_straight_vert_pole_long","title":"proj_straight_vert_pole_long  <code>property</code>","text":"<pre><code>proj_straight_vert_pole_long: float | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.projected_type","title":"projected_type  <code>property</code>","text":"<pre><code>projected_type: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.projection","title":"projection  <code>property</code>","text":"<pre><code>projection: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.raster_type","title":"raster_type  <code>property</code>","text":"<pre><code>raster_type: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.vertical","title":"vertical  <code>property</code>","text":"<pre><code>vertical: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.vertical_citation","title":"vertical_citation  <code>property</code>","text":"<pre><code>vertical_citation: str | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.vertical_datum","title":"vertical_datum  <code>property</code>","text":"<pre><code>vertical_datum: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.vertical_units","title":"vertical_units  <code>property</code>","text":"<pre><code>vertical_units: int | None\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Access GeoKey fields by string key.</p>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[str]\n</code></pre> <p>An iterable of string keys representing the GeoKey fields.</p>"},{"location":"api/geo/#async_tiff.GeoKeyDirectory.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>A list of string keys representing the GeoKey fields.</p>"},{"location":"api/ifd/","title":"IFD","text":""},{"location":"api/ifd/#async_tiff.ImageFileDirectory","title":"async_tiff.ImageFileDirectory","text":""},{"location":"api/ifd/#async_tiff.ImageFileDirectory.artist","title":"artist  <code>property</code>","text":"<pre><code>artist: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.bits_per_sample","title":"bits_per_sample  <code>property</code>","text":"<pre><code>bits_per_sample: list[int]\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.compression","title":"compression  <code>property</code>","text":"<pre><code>compression: CompressionMethod | int\n</code></pre> <p>Access the compression tag.</p> <p>An <code>int</code> will be returned if the compression is not one of the values in <code>CompressionMethod</code>.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.copyright","title":"copyright  <code>property</code>","text":"<pre><code>copyright: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.date_time","title":"date_time  <code>property</code>","text":"<pre><code>date_time: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.document_name","title":"document_name  <code>property</code>","text":"<pre><code>document_name: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.extra_samples","title":"extra_samples  <code>property</code>","text":"<pre><code>extra_samples: list[int] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.geo_key_directory","title":"geo_key_directory  <code>property</code>","text":"<pre><code>geo_key_directory: GeoKeyDirectory | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.host_computer","title":"host_computer  <code>property</code>","text":"<pre><code>host_computer: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.image_description","title":"image_description  <code>property</code>","text":"<pre><code>image_description: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.image_height","title":"image_height  <code>property</code>","text":"<pre><code>image_height: int\n</code></pre> <p>The number of rows of pixels in the image.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.image_width","title":"image_width  <code>property</code>","text":"<pre><code>image_width: int\n</code></pre> <p>The number of columns in the image, i.e., the number of pixels per row.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.jpeg_tables","title":"jpeg_tables  <code>property</code>","text":"<pre><code>jpeg_tables: bytes | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.max_sample_value","title":"max_sample_value  <code>property</code>","text":"<pre><code>max_sample_value: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.min_sample_value","title":"min_sample_value  <code>property</code>","text":"<pre><code>min_sample_value: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.model_pixel_scale","title":"model_pixel_scale  <code>property</code>","text":"<pre><code>model_pixel_scale: list[float] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.model_tiepoint","title":"model_tiepoint  <code>property</code>","text":"<pre><code>model_tiepoint: list[float] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.new_subfile_type","title":"new_subfile_type  <code>property</code>","text":"<pre><code>new_subfile_type: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.orientation","title":"orientation  <code>property</code>","text":"<pre><code>orientation: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.other_tags","title":"other_tags  <code>property</code>","text":"<pre><code>other_tags: dict[int, Value]\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.photometric_interpretation","title":"photometric_interpretation  <code>property</code>","text":"<pre><code>photometric_interpretation: PhotometricInterpretation\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.planar_configuration","title":"planar_configuration  <code>property</code>","text":"<pre><code>planar_configuration: PlanarConfiguration\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.predictor","title":"predictor  <code>property</code>","text":"<pre><code>predictor: Predictor | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.resolution_unit","title":"resolution_unit  <code>property</code>","text":"<pre><code>resolution_unit: ResolutionUnit | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.rows_per_strip","title":"rows_per_strip  <code>property</code>","text":"<pre><code>rows_per_strip: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.sample_format","title":"sample_format  <code>property</code>","text":"<pre><code>sample_format: list[SampleFormat]\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.samples_per_pixel","title":"samples_per_pixel  <code>property</code>","text":"<pre><code>samples_per_pixel: int\n</code></pre> <p>The number of components per pixel.</p> <p>SamplesPerPixel is usually 1 for bilevel, grayscale, and palette-color images. SamplesPerPixel is usually 3 for RGB images. If this value is higher, ExtraSamples should give an indication of the meaning of the additional channels.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.software","title":"software  <code>property</code>","text":"<pre><code>software: str | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.strip_byte_counts","title":"strip_byte_counts  <code>property</code>","text":"<pre><code>strip_byte_counts: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.strip_offsets","title":"strip_offsets  <code>property</code>","text":"<pre><code>strip_offsets: list[int] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.tile_byte_counts","title":"tile_byte_counts  <code>property</code>","text":"<pre><code>tile_byte_counts: list[int] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.tile_offsets","title":"tile_offsets  <code>property</code>","text":"<pre><code>tile_offsets: list[int] | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int | None\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.x_resolution","title":"x_resolution  <code>property</code>","text":"<pre><code>x_resolution: float | None\n</code></pre> <p>The number of pixels per ResolutionUnit in the ImageWidth direction.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.y_resolution","title":"y_resolution  <code>property</code>","text":"<pre><code>y_resolution: float | None\n</code></pre> <p>The number of pixels per ResolutionUnit in the ImageLength direction.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Access IFD fields by string key.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterable[str]\n</code></pre> <p>An iterable of string keys representing the IFD fields.</p>"},{"location":"api/ifd/#async_tiff.ImageFileDirectory.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>A list of string keys representing the IFD fields.</p>"},{"location":"api/thread-pool/","title":"Thread Pool","text":""},{"location":"api/thread-pool/#async_tiff.ThreadPool","title":"async_tiff.ThreadPool","text":"<p>A Rust-managed thread pool.</p>"},{"location":"api/thread-pool/#async_tiff.ThreadPool.__init__","title":"__init__","text":"<pre><code>__init__(num_threads: int) -&gt; None\n</code></pre> <p>Construct a new ThreadPool with the given number of threads.</p>"},{"location":"api/tiff/","title":"TIFF","text":""},{"location":"api/tiff/#async_tiff.TIFF","title":"async_tiff.TIFF","text":""},{"location":"api/tiff/#async_tiff.TIFF.endianness","title":"endianness  <code>property</code>","text":"<pre><code>endianness: Endianness\n</code></pre> <p>The endianness of this TIFF file.</p>"},{"location":"api/tiff/#async_tiff.TIFF.ifds","title":"ifds  <code>property</code>","text":"<pre><code>ifds: list[ImageFileDirectory]\n</code></pre> <p>Access the underlying IFDs of this TIFF.</p> <p>Each ImageFileDirectory (IFD) represents one of the internal \"sub images\" of this file.</p>"},{"location":"api/tiff/#async_tiff.TIFF.fetch_tile","title":"fetch_tile  <code>async</code>","text":"<pre><code>fetch_tile(x: int, y: int, z: int) -&gt; Tile\n</code></pre> <p>Fetch a single tile.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>int</code>)           \u2013            <p>The column index within the ifd to read from.</p> </li> <li> <code>y</code>               (<code>int</code>)           \u2013            <p>The row index within the ifd to read from.</p> </li> <li> <code>z</code>               (<code>int</code>)           \u2013            <p>The IFD index to read from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tile</code>           \u2013            <p>Tile response.</p> </li> </ul>"},{"location":"api/tiff/#async_tiff.TIFF.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(x: list[int], y: list[int], z: int) -&gt; list[Tile]\n</code></pre> <p>Fetch multiple tiles concurrently.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list[int]</code>)           \u2013            <p>The column indexes within the ifd to read from.</p> </li> <li> <code>y</code>               (<code>list[int]</code>)           \u2013            <p>The row indexes within the ifd to read from.</p> </li> <li> <code>z</code>               (<code>int</code>)           \u2013            <p>The IFD index to read from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Tile]</code>           \u2013            <p>Tile responses.</p> </li> </ul>"},{"location":"api/tiff/#async_tiff.TIFF.open","title":"open  <code>async</code> <code>classmethod</code>","text":"<pre><code>open(\n    path: str,\n    *,\n    store: ObjectStore | ObspecInput,\n    prefetch: int = 32768,\n    multiplier: int | float = 2.0,\n) -&gt; TIFF\n</code></pre> <p>Open a new TIFF.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore | ObspecInput</code>)           \u2013            <p>The backend to use for data fetching.</p> </li> <li> <code>prefetch</code>               (<code>int</code>, default:                   <code>32768</code> )           \u2013            <p>The number of initial bytes to read up front.</p> </li> <li> <code>multiplier</code>               (<code>int | float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier to use for readahead size growth. Must be greater than 1.0. For example, for a value of <code>2.0</code>, the first metadata read will be of size <code>prefetch</code>, and then the next read will be of size <code>prefetch * 2</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TIFF</code>           \u2013            <p>A TIFF instance.</p> </li> </ul>"},{"location":"api/tiff/#async_tiff.ObspecInput","title":"async_tiff.ObspecInput","text":"<p>               Bases: <code>GetRangeAsync</code>, <code>GetRangesAsync</code>, <code>Protocol</code></p> <p>Supported obspec input to reader.</p>"},{"location":"api/tile/","title":"Tile","text":""},{"location":"api/tile/#async_tiff.Tile","title":"async_tiff.Tile","text":"<p>A representation of a TIFF image tile.</p>"},{"location":"api/tile/#async_tiff.Tile.compressed_bytes","title":"compressed_bytes  <code>property</code>","text":"<pre><code>compressed_bytes: Buffer\n</code></pre> <p>The compressed bytes underlying this tile.</p>"},{"location":"api/tile/#async_tiff.Tile.compression_method","title":"compression_method  <code>property</code>","text":"<pre><code>compression_method: CompressionMethod | int\n</code></pre> <p>The compression method used by this tile.</p>"},{"location":"api/tile/#async_tiff.Tile.x","title":"x  <code>property</code>","text":"<pre><code>x: int\n</code></pre> <p>The column index this tile represents.</p>"},{"location":"api/tile/#async_tiff.Tile.y","title":"y  <code>property</code>","text":"<pre><code>y: int\n</code></pre> <p>The row index this tile represents.</p>"},{"location":"api/tile/#async_tiff.Tile.decode_async","title":"decode_async  <code>async</code>","text":"<pre><code>decode_async(\n    *,\n    decoder_registry: DecoderRegistry | None = None,\n    pool: ThreadPool | None = None,\n) -&gt; Buffer\n</code></pre> <p>Decode this tile's data.</p> <p>Other Parameters:</p> <ul> <li> <code>decoder_registry</code>               (<code>DecoderRegistry | None</code>)           \u2013            <p>the decoders to use for decompression. Defaults to None.</p> </li> <li> <code>pool</code>               (<code>ThreadPool | None</code>)           \u2013            <p>the thread pool on which to run decompression. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Buffer</code>           \u2013            <p>Decoded tile data as a buffer.</p> </li> </ul>"},{"location":"api/store/","title":"ObjectStore","text":""},{"location":"api/store/#async_tiff.store.from_url","title":"async_tiff.store.from_url","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: S3Config | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: S3CredentialProvider | None = None,\n    **kwargs: Unpack[S3Config],\n) -&gt; ObjectStore\n</code></pre><pre><code>from_url(\n    url: str,\n    *,\n    config: GCSConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: GCSCredentialProvider | None = None,\n    **kwargs: Unpack[GCSConfig],\n) -&gt; ObjectStore\n</code></pre><pre><code>from_url(\n    url: str,\n    *,\n    config: AzureConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: AzureCredentialProvider | None = None,\n    **kwargs: Unpack[AzureConfig],\n) -&gt; ObjectStore\n</code></pre><pre><code>from_url(\n    url: str,\n    *,\n    config: None = None,\n    client_options: None = None,\n    retry_config: None = None,\n    automatic_cleanup: bool = False,\n    mkdir: bool = False,\n) -&gt; ObjectStore\n</code></pre> <pre><code>from_url(\n    url: str,\n    *,\n    config: S3Config | GCSConfig | AzureConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: Callable | None = None,\n    **kwargs: Any,\n) -&gt; ObjectStore\n</code></pre> <p>Easy construction of store by URL, identifying the relevant store.</p> <p>This will defer to a store-specific <code>from_url</code> constructor based on the provided <code>url</code>. E.g. passing <code>\"s3://bucket/path\"</code> will defer to <code>S3Store.from_url</code>.</p> <p>Supported formats:</p> <ul> <li><code>file:///path/to/my/file</code> -&gt; <code>LocalStore</code></li> <li><code>memory:///</code> -&gt; <code>MemoryStore</code></li> <li><code>s3://bucket/path</code> -&gt; <code>S3Store</code> (also supports <code>s3a</code>)</li> <li><code>gs://bucket/path</code> -&gt; <code>GCSStore</code></li> <li><code>az://account/container/path</code> -&gt; <code>AzureStore</code> (also   supports <code>adl</code>, <code>azure</code>, <code>abfs</code>, <code>abfss</code>)</li> <li><code>http://mydomain/path</code> -&gt; <code>HTTPStore</code></li> <li><code>https://mydomain/path</code> -&gt; <code>HTTPStore</code></li> </ul> <p>There are also special cases for AWS and Azure for <code>https://{host?}/path</code> paths:</p> <ul> <li><code>dfs.core.windows.net</code>, <code>blob.core.windows.net</code>, <code>dfs.fabric.microsoft.com</code>,   <code>blob.fabric.microsoft.com</code> -&gt; <code>AzureStore</code></li> <li><code>amazonaws.com</code> -&gt; <code>S3Store</code></li> <li><code>r2.cloudflarestorage.com</code> -&gt; <code>S3Store</code></li> </ul> <p>Note</p> <p>For best static typing, use the constructors on individual store classes directly.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>S3Config | GCSConfig | AzureConfig | None</code>)           \u2013            <p>per-store Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>Callable | None</code>)           \u2013            <p>A callback to provide custom credentials to the underlying store classes.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            <p>per-store configuration passed down to store-specific builders.</p> </li> </ul>"},{"location":"api/store/#async_tiff.store.ObjectStore","title":"async_tiff.store.ObjectStore  <code>module-attribute</code>","text":"<pre><code>ObjectStore: TypeAlias = (\n    AzureStore | GCSStore | HTTPStore | S3Store | LocalStore | MemoryStore\n)\n</code></pre> <p>All supported ObjectStore implementations.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import ObjectStore\n</code></pre>"},{"location":"api/store/aws/","title":"AWS S3","text":""},{"location":"api/store/aws/#async_tiff.store.S3Store","title":"async_tiff.store.S3Store","text":"<p>Interface to an Amazon S3 bucket.</p> <p>All constructors will check for environment variables. Refer to <code>S3Config</code> for valid environment variables.</p> <p>Examples:</p> <p>Using requester-pays buckets:</p> <p>Pass <code>request_payer=True</code> as a keyword argument or have <code>AWS_REQUESTER_PAYS=True</code> set in the environment.</p> <p>Anonymous requests:</p> <p>Pass <code>skip_signature=True</code> as a keyword argument or have <code>AWS_SKIP_SIGNATURE=True</code> set in the environment.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.client_options","title":"client_options  <code>property</code>","text":"<pre><code>client_options: ClientConfig | None\n</code></pre> <p>Get the store's client configuration.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.config","title":"config  <code>property</code>","text":"<pre><code>config: S3Config\n</code></pre> <p>Get the underlying S3 config parameters.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.credential_provider","title":"credential_provider  <code>property</code>","text":"<pre><code>credential_provider: S3CredentialProvider | None\n</code></pre> <p>Get the store's credential provider.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str | None\n</code></pre> <p>Get the prefix applied to all operations in this store, if any.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.retry_config","title":"retry_config  <code>property</code>","text":"<pre><code>retry_config: RetryConfig | None\n</code></pre> <p>Get the store's retry configuration.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Store.__init__","title":"__init__","text":"<pre><code>__init__(\n    bucket: str | None = None,\n    *,\n    prefix: str | None = None,\n    config: S3Config | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: S3CredentialProvider | None = None,\n    **kwargs: Unpack[S3Config],\n) -&gt; None\n</code></pre> <p>Create a new S3Store.</p> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The AWS bucket to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>A prefix within the bucket to use for all operations.</p> </li> <li> <code>config</code>               (<code>S3Config | None</code>)           \u2013            <p>AWS configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>S3CredentialProvider | None</code>)           \u2013            <p>A callback to provide custom S3 credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[S3Config]</code>)           \u2013            <p>AWS configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#async_tiff.store.S3Store.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: S3Config | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: S3CredentialProvider | None = None,\n    **kwargs: Unpack[S3Config],\n) -&gt; Self\n</code></pre> <p>Parse available connection info from a well-known storage URL.</p> <p>Any path on the URL will be assigned as the <code>prefix</code> for the store. So if you pass <code>s3://bucket/path/to/directory</code>, the store will be created with a prefix of <code>path/to/directory</code>, and all further operations will use paths relative to that prefix.</p> <p>The supported url schemes are:</p> <ul> <li><code>s3://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>s3a://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>https://s3.&lt;region&gt;.amazonaws.com/&lt;bucket&gt;</code></li> <li><code>https://&lt;bucket&gt;.s3.&lt;region&gt;.amazonaws.com</code></li> <li><code>https://ACCOUNT_ID.r2.cloudflarestorage.com/bucket</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>config</code>               (<code>S3Config | None</code>)           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>S3CredentialProvider | None</code>)           \u2013            <p>A callback to provide custom S3 credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[S3Config]</code>)           \u2013            <p>AWS configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#async_tiff.store.S3Config","title":"async_tiff.store.S3Config","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration parameters for S3Store.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import S3Config\n</code></pre>"},{"location":"api/store/aws/#async_tiff.store.S3Config.access_key_id","title":"access_key_id  <code>instance-attribute</code>","text":"<pre><code>access_key_id: str\n</code></pre> <p>AWS Access Key.</p> <p>Environment variable: <code>AWS_ACCESS_KEY_ID</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.bucket","title":"bucket  <code>instance-attribute</code>","text":"<pre><code>bucket: str\n</code></pre> <p>Bucket name (required).</p> <p>Environment variables:</p> <ul> <li><code>AWS_BUCKET</code></li> <li><code>AWS_BUCKET_NAME</code></li> </ul>"},{"location":"api/store/aws/#async_tiff.store.S3Config.checksum_algorithm","title":"checksum_algorithm  <code>instance-attribute</code>","text":"<pre><code>checksum_algorithm: S3ChecksumAlgorithm | str\n</code></pre> <p>Sets the checksum algorithm which has to be used for object integrity check during upload.</p> <p>Environment variable: <code>AWS_CHECKSUM_ALGORITHM</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.conditional_put","title":"conditional_put  <code>instance-attribute</code>","text":"<pre><code>conditional_put: str\n</code></pre> <p>Configure how to provide conditional put support</p> <p>Supported values:</p> <ul> <li> <p><code>\"etag\"</code> (default): Supported for S3-compatible stores that support conditional     put using the standard HTTP precondition headers <code>If-Match</code> and     <code>If-None-Match</code>.</p> </li> <li> <p><code>\"dynamo:&lt;TABLE_NAME&gt;\"</code> or <code>\"dynamo:&lt;TABLE_NAME&gt;:&lt;TIMEOUT_MILLIS&gt;\"</code>: The name of a DynamoDB table to use for coordination.</p> <p>This will use the same region, credentials and endpoint as configured for S3.</p> </li> </ul> <p>Environment variable: <code>AWS_CONDITIONAL_PUT</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.container_credentials_relative_uri","title":"container_credentials_relative_uri  <code>instance-attribute</code>","text":"<pre><code>container_credentials_relative_uri: str\n</code></pre> <p>Set the container credentials relative URI</p> <p>docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html</p> <p>Environment variable: <code>AWS_CONTAINER_CREDENTIALS_RELATIVE_URI</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.copy_if_not_exists","title":"copy_if_not_exists  <code>instance-attribute</code>","text":"<pre><code>copy_if_not_exists: Literal['multipart'] | str\n</code></pre> <p>Configure how to provide \"copy if not exists\".</p> <p>Supported values:</p> <ul> <li> <p><code>\"multipart\"</code>:</p> <p>Native Amazon S3 supports copy if not exists through a multipart upload where the upload copies an existing object and is completed only if the new object does not already exist.</p> <p>Warning</p> <p>When using this mode, <code>copy_if_not_exists</code> does not copy tags or attributes from the source object.</p> <p>Warning</p> <p>When using this mode, <code>copy_if_not_exists</code> makes only a best effort attempt to clean up the multipart upload if the copy operation fails. Consider using a lifecycle rule to automatically clean up abandoned multipart uploads.</p> </li> <li> <p><code>\"header:&lt;HEADER_NAME&gt;:&lt;HEADER_VALUE&gt;\"</code>:</p> <p>Some S3-compatible stores, such as Cloudflare R2, support copy if not exists semantics through custom headers.</p> <p>If set, <code>copy_if_not_exists</code> will perform a normal copy operation with the provided header pair, and expect the store to fail with <code>412 Precondition Failed</code> if the destination file already exists.</p> <p>For example <code>header: cf-copy-destination-if-none-match: *</code>, would set the header <code>cf-copy-destination-if-none-match</code> to <code>*</code>.</p> </li> <li> <p><code>\"header-with-status:&lt;HEADER_NAME&gt;:&lt;HEADER_VALUE&gt;:&lt;STATUS&gt;\"</code>:</p> <p>The same as the header variant above but allows custom status code checking, for object stores that return values other than 412.</p> </li> <li> <p><code>\"dynamo:&lt;TABLE_NAME&gt;\"</code> or <code>\"dynamo:&lt;TABLE_NAME&gt;:&lt;TIMEOUT_MILLIS&gt;\"</code>:</p> <p>The name of a DynamoDB table to use for coordination.</p> <p>The default timeout is used if not specified. This will use the same region, credentials and endpoint as configured for S3.</p> </li> </ul> <p>Environment variable: <code>AWS_COPY_IF_NOT_EXISTS</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.default_region","title":"default_region  <code>instance-attribute</code>","text":"<pre><code>default_region: S3Regions | str\n</code></pre> <p>Default region.</p> <p>Environment variable: <code>AWS_DEFAULT_REGION</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.disable_tagging","title":"disable_tagging  <code>instance-attribute</code>","text":"<pre><code>disable_tagging: bool\n</code></pre> <p>Disable tagging objects. This can be desirable if not supported by the backing store.</p> <p>Environment variable: <code>AWS_DISABLE_TAGGING</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.endpoint","title":"endpoint  <code>instance-attribute</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>The endpoint for communicating with AWS S3.</p> <p>Defaults to the region endpoint.</p> <p>For example, this might be set to <code>\"http://localhost:4566:</code> for testing against a localstack instance.</p> <p>The <code>endpoint</code> field should be consistent with <code>with_virtual_hosted_style_request</code>, i.e. if <code>virtual_hosted_style_request</code> is set to <code>True</code> then <code>endpoint</code> should have the bucket name included.</p> <p>By default, only HTTPS schemes are enabled. To connect to an HTTP endpoint, enable <code>allow_http</code> in the client options.</p> <p>Environment variables:</p> <ul> <li><code>AWS_ENDPOINT_URL</code></li> <li><code>AWS_ENDPOINT</code></li> </ul>"},{"location":"api/store/aws/#async_tiff.store.S3Config.imdsv1_fallback","title":"imdsv1_fallback  <code>instance-attribute</code>","text":"<pre><code>imdsv1_fallback: bool\n</code></pre> <p>Fall back to ImdsV1.</p> <p>By default instance credentials will only be fetched over IMDSv2, as AWS recommends against having IMDSv1 enabled on EC2 instances as it is vulnerable to SSRF attack</p> <p>However, certain deployment environments, such as those running old versions of kube2iam, may not support IMDSv2. This option will enable automatic fallback to using IMDSv1 if the token endpoint returns a 403 error indicating that IMDSv2 is not supported.</p> <p>This option has no effect if not using instance credentials.</p> <p>Environment variable: <code>AWS_IMDSV1_FALLBACK</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.metadata_endpoint","title":"metadata_endpoint  <code>instance-attribute</code>","text":"<pre><code>metadata_endpoint: str\n</code></pre> <p>Set the [instance metadata endpoint], used primarily within AWS EC2.</p> <p>This defaults to the IPv4 endpoint: <code>http://169.254.169.254</code>. One can alternatively use the IPv6 endpoint <code>http://fd00:ec2::254</code>.</p> <p>Environment variable: <code>AWS_METADATA_ENDPOINT</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: S3Regions | str\n</code></pre> <p>The region, defaults to <code>us-east-1</code></p> <p>Environment variable: <code>AWS_REGION</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.request_payer","title":"request_payer  <code>instance-attribute</code>","text":"<pre><code>request_payer: bool\n</code></pre> <p>If <code>True</code>, enable operations on requester-pays buckets.</p> <p>docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html</p> <p>Environment variable: <code>AWS_REQUEST_PAYER</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.s3_express","title":"s3_express  <code>instance-attribute</code>","text":"<pre><code>s3_express: bool\n</code></pre> <p>Enable Support for S3 Express One Zone.</p> <p>Environment variable: <code>AWS_S3_EXPRESS</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.secret_access_key","title":"secret_access_key  <code>instance-attribute</code>","text":"<pre><code>secret_access_key: str\n</code></pre> <p>Secret Access Key.</p> <p>Environment variable: <code>AWS_SECRET_ACCESS_KEY</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.server_side_encryption","title":"server_side_encryption  <code>instance-attribute</code>","text":"<pre><code>server_side_encryption: S3EncryptionAlgorithm | str\n</code></pre> <p>Type of encryption to use.</p> <p>If set, must be one of:</p> <ul> <li><code>\"AES256\"</code> (SSE-S3)</li> <li><code>\"aws:kms\"</code> (SSE-KMS)</li> <li><code>\"aws:kms:dsse\"</code> (DSSE-KMS)</li> <li><code>\"sse-c\"</code></li> </ul> <p>Environment variable: <code>AWS_SERVER_SIDE_ENCRYPTION</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.session_token","title":"session_token  <code>instance-attribute</code>","text":"<pre><code>session_token: str\n</code></pre> <p>Token to use for requests (passed to underlying provider).</p> <p>Environment variables:</p> <ul> <li><code>AWS_SESSION_TOKEN</code></li> <li><code>AWS_TOKEN</code></li> </ul>"},{"location":"api/store/aws/#async_tiff.store.S3Config.skip_signature","title":"skip_signature  <code>instance-attribute</code>","text":"<pre><code>skip_signature: bool\n</code></pre> <p>If <code>True</code>, S3Store will not fetch credentials and will not sign requests.</p> <p>This can be useful when interacting with public S3 buckets that deny authorized requests.</p> <p>Environment variable: <code>AWS_SKIP_SIGNATURE</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.sse_bucket_key_enabled","title":"sse_bucket_key_enabled  <code>instance-attribute</code>","text":"<pre><code>sse_bucket_key_enabled: bool\n</code></pre> <p>Set whether to enable bucket key for server side encryption.</p> <p>This overrides the bucket default setting for bucket keys.</p> <ul> <li>When <code>False</code>, each object is encrypted with a unique data key.</li> <li>When <code>True</code>, a single data key is used for the entire bucket,   reducing overhead of encryption.</li> </ul> <p>Environment variable: <code>AWS_SSE_BUCKET_KEY_ENABLED</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.sse_customer_key_base64","title":"sse_customer_key_base64  <code>instance-attribute</code>","text":"<pre><code>sse_customer_key_base64: str\n</code></pre> <p>The base64 encoded, 256-bit customer encryption key to use for server-side encryption. If set, the server side encryption config value must be <code>\"sse-c\"</code>.</p> <p>Environment variable: <code>AWS_SSE_CUSTOMER_KEY_BASE64</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.sse_kms_key_id","title":"sse_kms_key_id  <code>instance-attribute</code>","text":"<pre><code>sse_kms_key_id: str\n</code></pre> <p>The KMS key ID to use for server-side encryption.</p> <p>If set, the server side encryption config value must be <code>\"aws:kms\"</code> or <code>\"aws:kms:dsse\"</code>.</p> <p>Environment variable: <code>AWS_SSE_KMS_KEY_ID</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.unsigned_payload","title":"unsigned_payload  <code>instance-attribute</code>","text":"<pre><code>unsigned_payload: bool\n</code></pre> <p>Avoid computing payload checksum when calculating signature.</p> <p>See unsigned payload option.</p> <ul> <li><code>False</code> (default): Signed payload option is used, where the checksum for the request body is computed and included when constructing a canonical request.</li> <li><code>True</code>: Unsigned payload option is used. <code>UNSIGNED-PAYLOAD</code> literal is included when constructing a canonical request,</li> </ul> <p>Environment variable: <code>AWS_UNSIGNED_PAYLOAD</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Config.virtual_hosted_style_request","title":"virtual_hosted_style_request  <code>instance-attribute</code>","text":"<pre><code>virtual_hosted_style_request: bool\n</code></pre> <p>If virtual hosted style request has to be used.</p> <p>If <code>virtual_hosted_style_request</code> is:</p> <ul> <li><code>False</code> (default):  Path style request is used</li> <li><code>True</code>:  Virtual hosted style request is used</li> </ul> <p>If the <code>endpoint</code> is provided then it should be consistent with <code>virtual_hosted_style_request</code>. i.e. if <code>virtual_hosted_style_request</code> is set to <code>True</code> then <code>endpoint</code> should have bucket name included.</p> <p>Environment variable: <code>AWS_VIRTUAL_HOSTED_STYLE_REQUEST</code>.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Credential","title":"async_tiff.store.S3Credential","text":"<p>               Bases: <code>TypedDict</code></p> <p>An S3 credential.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import S3Credential\n</code></pre>"},{"location":"api/store/aws/#async_tiff.store.S3Credential.access_key_id","title":"access_key_id  <code>instance-attribute</code>","text":"<pre><code>access_key_id: str\n</code></pre> <p>AWS access key ID.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Credential.expires_at","title":"expires_at  <code>instance-attribute</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Expiry datetime of credential. The datetime should have time zone set.</p> <p>If None, the credential will never expire.</p>"},{"location":"api/store/aws/#async_tiff.store.S3Credential.secret_access_key","title":"secret_access_key  <code>instance-attribute</code>","text":"<pre><code>secret_access_key: str\n</code></pre> <p>AWS secret access key</p>"},{"location":"api/store/aws/#async_tiff.store.S3Credential.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: NotRequired[str | None]\n</code></pre> <p>AWS token.</p>"},{"location":"api/store/aws/#async_tiff.store.S3CredentialProvider","title":"async_tiff.store.S3CredentialProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>A type hint for a synchronous or asynchronous callback to provide custom S3 credentials.</p> <p>This should be passed into the <code>credential_provider</code> parameter of <code>S3Store</code>.</p> <p>Examples:</p> <p>Return static credentials that don't expire: <pre><code>def get_credentials() -&gt; S3Credential:\n    return {\n        \"access_key_id\": \"...\",\n        \"secret_access_key\": \"...\",\n        \"token\": None,\n        \"expires_at\": None,\n    }\n</code></pre></p> <p>Return static credentials that are valid for 5 minutes: <pre><code>from datetime import datetime, timedelta, UTC\n\nasync def get_credentials() -&gt; S3Credential:\n    return {\n        \"access_key_id\": \"...\",\n        \"secret_access_key\": \"...\",\n        \"token\": None,\n        \"expires_at\": datetime.now(UTC) + timedelta(minutes=5),\n    }\n</code></pre></p> <p>A class-based credential provider with state:</p> <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport boto3\nimport botocore.credentials\n\nif TYPE_CHECKING:\n    from obstore.store import S3Credential\n\n\nclass Boto3CredentialProvider:\n    credentials: botocore.credentials.Credentials\n\n    def __init__(self, session: boto3.session.Session) -&gt; None:\n        credentials = session.get_credentials()\n        if credentials is None:\n            raise ValueError(\"Received None from session.get_credentials\")\n\n        self.credentials = credentials\n\n    def __call__(self) -&gt; S3Credential:\n        frozen_credentials = self.credentials.get_frozen_credentials()\n        return {\n            \"access_key_id\": frozen_credentials.access_key,\n            \"secret_access_key\": frozen_credentials.secret_key,\n            \"token\": frozen_credentials.token,\n            \"expires_at\": None,\n        }\n</code></pre> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import S3CredentialProvider\n</code></pre>"},{"location":"api/store/aws/#async_tiff.store.S3CredentialProvider.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; S3Credential | Coroutine[Any, Any, S3Credential]\n</code></pre> <p>Return an <code>S3Credential</code>.</p>"},{"location":"api/store/azure/","title":"Microsoft Azure","text":""},{"location":"api/store/azure/#async_tiff.store.AzureStore","title":"async_tiff.store.AzureStore","text":"<p>Interface to a Microsoft Azure Blob Storage container.</p> <p>All constructors will check for environment variables. Refer to <code>AzureConfig</code> for valid environment variables.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.client_options","title":"client_options  <code>property</code>","text":"<pre><code>client_options: ClientConfig | None\n</code></pre> <p>Get the store's client configuration.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.config","title":"config  <code>property</code>","text":"<pre><code>config: AzureConfig\n</code></pre> <p>Get the underlying Azure config parameters.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.credential_provider","title":"credential_provider  <code>property</code>","text":"<pre><code>credential_provider: AzureCredentialProvider | None\n</code></pre> <p>Get the store's credential provider.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str | None\n</code></pre> <p>Get the prefix applied to all operations in this store, if any.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.retry_config","title":"retry_config  <code>property</code>","text":"<pre><code>retry_config: RetryConfig | None\n</code></pre> <p>Get the store's retry configuration.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    container_name: str | None = None,\n    *,\n    prefix: str | None = None,\n    config: AzureConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: AzureCredentialProvider | None = None,\n    **kwargs: Unpack[AzureConfig],\n) -&gt; None\n</code></pre> <p>Construct a new AzureStore.</p> <p>Parameters:</p> <ul> <li> <code>container_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>the name of the container.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>A prefix within the bucket to use for all operations.</p> </li> <li> <code>config</code>               (<code>AzureConfig | None</code>)           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>AzureCredentialProvider | None</code>)           \u2013            <p>A callback to provide custom Azure credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[AzureConfig]</code>)           \u2013            <p>Azure configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    prefix: str | None = None,\n    config: AzureConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: AzureCredentialProvider | None = None,\n    **kwargs: Unpack[AzureConfig],\n) -&gt; Self\n</code></pre> <p>Construct a new AzureStore with values populated from a well-known storage URL.</p> <p>Any path on the URL will be assigned as the <code>prefix</code> for the store. So if you pass <code>https://&lt;account&gt;.blob.core.windows.net/&lt;container&gt;/path/to/directory</code>, the store will be created with a prefix of <code>path/to/directory</code>, and all further operations will use paths relative to that prefix.</p> <p>The supported url schemes are:</p> <ul> <li><code>abfs[s]://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.core.windows.net/&lt;path&gt;</code></li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.fabric.microsoft.com/&lt;path&gt;</code></li> <li><code>az://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>adl://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>azure://&lt;container&gt;/&lt;path&gt;</code> (custom)</li> <li><code>https://&lt;account&gt;.dfs.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com/&lt;container&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>A prefix within the bucket to use for all operations.</p> </li> <li> <code>config</code>               (<code>AzureConfig | None</code>)           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>AzureCredentialProvider | None</code>)           \u2013            <p>A callback to provide custom Azure credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[AzureConfig]</code>)           \u2013            <p>Azure configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureAccessKey","title":"async_tiff.store.AzureAccessKey","text":"<p>               Bases: <code>TypedDict</code></p> <p>A shared Azure Storage Account Key.</p> <p>learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureAccessKey\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureAccessKey.access_key","title":"access_key  <code>instance-attribute</code>","text":"<pre><code>access_key: str\n</code></pre> <p>Access key value.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureAccessKey.expires_at","title":"expires_at  <code>instance-attribute</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Expiry datetime of credential. The datetime should have time zone set.</p> <p>If None, the credential will never expire.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig","title":"async_tiff.store.AzureConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration parameters for AzureStore.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureConfig\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.account_key","title":"account_key  <code>instance-attribute</code>","text":"<pre><code>account_key: str\n</code></pre> <p>Master key for accessing storage account.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_ACCOUNT_KEY</code></li> <li><code>AZURE_STORAGE_ACCESS_KEY</code></li> <li><code>AZURE_STORAGE_MASTER_KEY</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.account_name","title":"account_name  <code>instance-attribute</code>","text":"<pre><code>account_name: str\n</code></pre> <p>The name of the azure storage account. (Required.)</p> <p>Environment variable: <code>AZURE_STORAGE_ACCOUNT_NAME</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.authority_host","title":"authority_host  <code>instance-attribute</code>","text":"<pre><code>authority_host: str\n</code></pre> <p>Sets an alternative authority host for OAuth based authorization.</p> <p>Defaults to <code>https://login.microsoftonline.com</code>.</p> <p>Common hosts for azure clouds are:</p> <ul> <li>Azure China: <code>\"https://login.chinacloudapi.cn\"</code></li> <li>Azure Germany: <code>\"https://login.microsoftonline.de\"</code></li> <li>Azure Government: <code>\"https://login.microsoftonline.us\"</code></li> <li>Azure Public: <code>\"https://login.microsoftonline.com\"</code></li> </ul> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_AUTHORITY_HOST</code></li> <li><code>AZURE_AUTHORITY_HOST</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id: str\n</code></pre> <p>The client id for use in client secret or k8s federated credential flow.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_CLIENT_ID</code></li> <li><code>AZURE_CLIENT_ID</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.client_secret","title":"client_secret  <code>instance-attribute</code>","text":"<pre><code>client_secret: str\n</code></pre> <p>The client secret for use in client secret flow.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_CLIENT_SECRET</code></li> <li><code>AZURE_CLIENT_SECRET</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.container_name","title":"container_name  <code>instance-attribute</code>","text":"<pre><code>container_name: str\n</code></pre> <p>Container name.</p> <p>Environment variable: <code>AZURE_CONTAINER_NAME</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.disable_tagging","title":"disable_tagging  <code>instance-attribute</code>","text":"<pre><code>disable_tagging: bool\n</code></pre> <p>If set to <code>True</code> will ignore any tags provided to uploads.</p> <p>Environment variable: <code>AZURE_DISABLE_TAGGING</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.endpoint","title":"endpoint  <code>instance-attribute</code>","text":"<pre><code>endpoint: str\n</code></pre> <p>Override the endpoint used to communicate with blob storage.</p> <p>Defaults to <code>https://{account}.blob.core.windows.net</code>.</p> <p>By default, only HTTPS schemes are enabled. To connect to an HTTP endpoint, enable <code>allow_http</code> in the client options.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_ENDPOINT</code></li> <li><code>AZURE_ENDPOINT</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.fabric_cluster_identifier","title":"fabric_cluster_identifier  <code>instance-attribute</code>","text":"<pre><code>fabric_cluster_identifier: str\n</code></pre> <p>Cluster identifier for Fabric OAuth2 authentication.</p> <p>Environment variable: <code>AZURE_FABRIC_CLUSTER_IDENTIFIER</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.fabric_session_token","title":"fabric_session_token  <code>instance-attribute</code>","text":"<pre><code>fabric_session_token: str\n</code></pre> <p>Session token for Fabric OAuth2 authentication.</p> <p>Environment variable: <code>AZURE_FABRIC_SESSION_TOKEN</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.fabric_token_service_url","title":"fabric_token_service_url  <code>instance-attribute</code>","text":"<pre><code>fabric_token_service_url: str\n</code></pre> <p>Service URL for Fabric OAuth2 authentication.</p> <p>Environment variable: <code>AZURE_FABRIC_TOKEN_SERVICE_URL</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.fabric_workload_host","title":"fabric_workload_host  <code>instance-attribute</code>","text":"<pre><code>fabric_workload_host: str\n</code></pre> <p>Workload host for Fabric OAuth2 authentication.</p> <p>Environment variable: <code>AZURE_FABRIC_WORKLOAD_HOST</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.federated_token_file","title":"federated_token_file  <code>instance-attribute</code>","text":"<pre><code>federated_token_file: str\n</code></pre> <p>Sets a file path for acquiring azure federated identity token in k8s.</p> <p>Requires <code>client_id</code> and <code>tenant_id</code> to be set.</p> <p>Environment variable: <code>AZURE_FEDERATED_TOKEN_FILE</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.msi_endpoint","title":"msi_endpoint  <code>instance-attribute</code>","text":"<pre><code>msi_endpoint: str\n</code></pre> <p>Endpoint to request a imds managed identity token.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_MSI_ENDPOINT</code></li> <li><code>AZURE_IDENTITY_ENDPOINT</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.msi_resource_id","title":"msi_resource_id  <code>instance-attribute</code>","text":"<pre><code>msi_resource_id: str\n</code></pre> <p>Msi resource id for use with managed identity authentication.</p> <p>Environment variable: <code>AZURE_MSI_RESOURCE_ID</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.object_id","title":"object_id  <code>instance-attribute</code>","text":"<pre><code>object_id: str\n</code></pre> <p>Object id for use with managed identity authentication.</p> <p>Environment variable: <code>AZURE_OBJECT_ID</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.sas_key","title":"sas_key  <code>instance-attribute</code>","text":"<pre><code>sas_key: str\n</code></pre> <p>Shared access signature.</p> <p>The signature is expected to be percent-encoded, <code>much</code>like they are provided in the azure storage explorer or azure portal.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_SAS_KEY</code></li> <li><code>AZURE_STORAGE_SAS_TOKEN</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.skip_signature","title":"skip_signature  <code>instance-attribute</code>","text":"<pre><code>skip_signature: bool\n</code></pre> <p>If enabled, <code>AzureStore</code> will not fetch credentials and will not sign requests.</p> <p>This can be useful when interacting with public containers.</p> <p>Environment variable: <code>AZURE_SKIP_SIGNATURE</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.tenant_id","title":"tenant_id  <code>instance-attribute</code>","text":"<pre><code>tenant_id: str\n</code></pre> <p>The tenant id for use in client secret or k8s federated credential flow.</p> <p>Environment variables:</p> <ul> <li><code>AZURE_STORAGE_TENANT_ID</code></li> <li><code>AZURE_STORAGE_AUTHORITY_ID</code></li> <li><code>AZURE_TENANT_ID</code></li> <li><code>AZURE_AUTHORITY_ID</code></li> </ul>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>A static bearer token to be used for authorizing requests.</p> <p>Environment variable: <code>AZURE_STORAGE_TOKEN</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.use_azure_cli","title":"use_azure_cli  <code>instance-attribute</code>","text":"<pre><code>use_azure_cli: bool\n</code></pre> <p>Set if the Azure Cli should be used for acquiring access token.</p> <p>learn.microsoft.com/en-us/cli/azure/account?view=azure-cli-latest#az-account-get-access-token.</p> <p>Environment variable: <code>AZURE_USE_AZURE_CLI</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.use_emulator","title":"use_emulator  <code>instance-attribute</code>","text":"<pre><code>use_emulator: bool\n</code></pre> <p>Set if the Azure emulator should be used (defaults to <code>False</code>).</p> <p>Environment variable: <code>AZURE_STORAGE_USE_EMULATOR</code>.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureConfig.use_fabric_endpoint","title":"use_fabric_endpoint  <code>instance-attribute</code>","text":"<pre><code>use_fabric_endpoint: bool\n</code></pre> <p>Set if Microsoft Fabric url scheme should be used (defaults to <code>False</code>).</p> <p>When disabled the url scheme used is <code>https://{account}.blob.core.windows.net</code>. When enabled the url scheme used is <code>https://{account}.dfs.fabric.microsoft.com</code>.</p> <p>Note</p> <p><code>endpoint</code> will take precedence over this option.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureSASToken","title":"async_tiff.store.AzureSASToken","text":"<p>               Bases: <code>TypedDict</code></p> <p>A shared access signature.</p> <p>learn.microsoft.com/en-us/rest/api/storageservices/delegate-access-with-shared-access-signature</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureSASToken\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureSASToken.expires_at","title":"expires_at  <code>instance-attribute</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Expiry datetime of credential. The datetime should have time zone set.</p> <p>If None, the credential will never expire.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureSASToken.sas_token","title":"sas_token  <code>instance-attribute</code>","text":"<pre><code>sas_token: str | list[tuple[str, str]]\n</code></pre> <p>SAS token.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureBearerToken","title":"async_tiff.store.AzureBearerToken","text":"<p>               Bases: <code>TypedDict</code></p> <p>An authorization token.</p> <p>learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-azure-active-directory</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureBearerToken\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureBearerToken.expires_at","title":"expires_at  <code>instance-attribute</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Expiry datetime of credential. The datetime should have time zone set.</p> <p>If None, the credential will never expire.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureBearerToken.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>Bearer token.</p>"},{"location":"api/store/azure/#async_tiff.store.AzureCredential","title":"async_tiff.store.AzureCredential  <code>module-attribute</code>","text":"<pre><code>AzureCredential: TypeAlias = AzureAccessKey | AzureSASToken | AzureBearerToken\n</code></pre> <p>A type alias for supported azure credentials to be returned from <code>AzureCredentialProvider</code>.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureCredential\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureCredentialProvider","title":"async_tiff.store.AzureCredentialProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>A type hint for a synchronous or asynchronous callback to provide custom Azure credentials.</p> <p>This should be passed into the <code>credential_provider</code> parameter of <code>AzureStore</code>.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import AzureCredentialProvider\n</code></pre>"},{"location":"api/store/azure/#async_tiff.store.AzureCredentialProvider.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; AzureCredential | Coroutine[Any, Any, AzureCredential]\n</code></pre> <p>Return an <code>AzureCredential</code>.</p>"},{"location":"api/store/config/","title":"Configuration","text":""},{"location":"api/store/config/#async_tiff.store.ClientConfig","title":"async_tiff.store.ClientConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>HTTP client configuration.</p> <p>For timeout values (<code>connect_timeout</code>, <code>http2_keep_alive_timeout</code>, <code>pool_idle_timeout</code>, and <code>timeout</code>), values can either be Python <code>timedelta</code> objects, or they can be \"human-readable duration strings\".</p> <p>The human-readable duration string is a concatenation of time spans. Where each time span is an integer number and a suffix. Supported suffixes:</p> <ul> <li><code>nsec</code>, <code>ns</code> -- nanoseconds</li> <li><code>usec</code>, <code>us</code> -- microseconds</li> <li><code>msec</code>, <code>ms</code> -- milliseconds</li> <li><code>seconds</code>, <code>second</code>, <code>sec</code>, <code>s</code></li> <li><code>minutes</code>, <code>minute</code>, <code>min</code>, <code>m</code></li> <li><code>hours</code>, <code>hour</code>, <code>hr</code>, <code>h</code></li> <li><code>days</code>, <code>day</code>, <code>d</code></li> <li><code>weeks</code>, <code>week</code>, <code>w</code></li> <li><code>months</code>, <code>month</code>, <code>M</code> -- defined as 30.44 days</li> <li><code>years</code>, <code>year</code>, <code>y</code> -- defined as 365.25 days</li> </ul> <p>For example:</p> <ul> <li><code>\"2h 37min\"</code></li> <li><code>\"32ms\"</code></li> </ul> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import ClientConfig\n</code></pre>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.allow_http","title":"allow_http  <code>instance-attribute</code>","text":"<pre><code>allow_http: bool\n</code></pre> <p>Allow non-TLS, i.e. non-HTTPS connections.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.allow_invalid_certificates","title":"allow_invalid_certificates  <code>instance-attribute</code>","text":"<pre><code>allow_invalid_certificates: bool\n</code></pre> <p>Skip certificate validation on https connections.</p> <p>Warning</p> <p>You should think very carefully before using this method. If invalid certificates are trusted, any certificate for any site will be trusted for use. This includes expired certificates. This introduces significant vulnerabilities, and should only be used as a last resort or for testing</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.connect_timeout","title":"connect_timeout  <code>instance-attribute</code>","text":"<pre><code>connect_timeout: str | timedelta\n</code></pre> <p>Timeout for only the connect phase of a Client</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.default_content_type","title":"default_content_type  <code>instance-attribute</code>","text":"<pre><code>default_content_type: str\n</code></pre> <p>Default <code>CONTENT_TYPE</code> for uploads</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.default_headers","title":"default_headers  <code>instance-attribute</code>","text":"<pre><code>default_headers: dict[str, str] | dict[str, bytes]\n</code></pre> <p>Default headers to be sent with each request</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.http1_only","title":"http1_only  <code>instance-attribute</code>","text":"<pre><code>http1_only: bool\n</code></pre> <p>Only use http1 connections.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.http2_keep_alive_interval","title":"http2_keep_alive_interval  <code>instance-attribute</code>","text":"<pre><code>http2_keep_alive_interval: str\n</code></pre> <p>Interval for HTTP2 Ping frames should be sent to keep a connection alive.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.http2_keep_alive_timeout","title":"http2_keep_alive_timeout  <code>instance-attribute</code>","text":"<pre><code>http2_keep_alive_timeout: str | timedelta\n</code></pre> <p>Timeout for receiving an acknowledgement of the keep-alive ping.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.http2_keep_alive_while_idle","title":"http2_keep_alive_while_idle  <code>instance-attribute</code>","text":"<pre><code>http2_keep_alive_while_idle: str\n</code></pre> <p>Enable HTTP2 keep alive pings for idle connections</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.http2_only","title":"http2_only  <code>instance-attribute</code>","text":"<pre><code>http2_only: bool\n</code></pre> <p>Only use http2 connections</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.pool_idle_timeout","title":"pool_idle_timeout  <code>instance-attribute</code>","text":"<pre><code>pool_idle_timeout: str | timedelta\n</code></pre> <p>The pool max idle timeout.</p> <p>This is the length of time an idle connection will be kept alive.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.pool_max_idle_per_host","title":"pool_max_idle_per_host  <code>instance-attribute</code>","text":"<pre><code>pool_max_idle_per_host: str\n</code></pre> <p>Maximum number of idle connections per host.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.proxy_url","title":"proxy_url  <code>instance-attribute</code>","text":"<pre><code>proxy_url: str\n</code></pre> <p>HTTP proxy to use for requests.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout: str | timedelta\n</code></pre> <p>Request timeout.</p> <p>The timeout is applied from when the request starts connecting until the response body has finished.</p>"},{"location":"api/store/config/#async_tiff.store.ClientConfig.user_agent","title":"user_agent  <code>instance-attribute</code>","text":"<pre><code>user_agent: str\n</code></pre> <p>User-Agent header to be used by this client.</p>"},{"location":"api/store/config/#async_tiff.store.BackoffConfig","title":"async_tiff.store.BackoffConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Exponential backoff with jitter.</p> <p>See aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import BackoffConfig\n</code></pre>"},{"location":"api/store/config/#async_tiff.store.BackoffConfig.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base: int | float\n</code></pre> <p>The base of the exponential to use.</p> <p>Defaults to <code>2</code>.</p>"},{"location":"api/store/config/#async_tiff.store.BackoffConfig.init_backoff","title":"init_backoff  <code>instance-attribute</code>","text":"<pre><code>init_backoff: timedelta\n</code></pre> <p>The initial backoff duration.</p> <p>Defaults to 100 milliseconds.</p>"},{"location":"api/store/config/#async_tiff.store.BackoffConfig.max_backoff","title":"max_backoff  <code>instance-attribute</code>","text":"<pre><code>max_backoff: timedelta\n</code></pre> <p>The maximum backoff duration.</p> <p>Defaults to 15 seconds.</p>"},{"location":"api/store/config/#async_tiff.store.RetryConfig","title":"async_tiff.store.RetryConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>The configuration for how to respond to request errors.</p> <p>The following categories of error will be retried:</p> <ul> <li>5xx server errors</li> <li>Connection errors</li> <li>Dropped connections</li> <li>Timeouts for safe / read-only requests</li> </ul> <p>Requests will be retried up to some limit, using exponential backoff with jitter. See <code>BackoffConfig</code> for more information</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import RetryConfig\n</code></pre>"},{"location":"api/store/config/#async_tiff.store.RetryConfig.backoff","title":"backoff  <code>instance-attribute</code>","text":"<pre><code>backoff: BackoffConfig\n</code></pre> <p>The backoff configuration.</p> <p>Defaults to the values listed above if not provided.</p>"},{"location":"api/store/config/#async_tiff.store.RetryConfig.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries: int\n</code></pre> <p>The maximum number of times to retry a request</p> <p>Set to 0 to disable retries.</p> <p>Defaults to 10.</p>"},{"location":"api/store/config/#async_tiff.store.RetryConfig.retry_timeout","title":"retry_timeout  <code>instance-attribute</code>","text":"<pre><code>retry_timeout: timedelta\n</code></pre> <p>The maximum length of time from the initial request after which no further retries will be attempted</p> <p>This not only bounds the length of time before a server error will be surfaced to the application, but also bounds the length of time a request's credentials must remain valid.</p> <p>As requests are retried without renewing credentials or regenerating request payloads, this number should be kept below 5 minutes to avoid errors due to expired credentials and/or request payloads.</p> <p>Defaults to 3 minutes.</p>"},{"location":"api/store/gcs/","title":"Google Cloud Storage","text":""},{"location":"api/store/gcs/#async_tiff.store.GCSStore","title":"async_tiff.store.GCSStore","text":"<p>Interface to Google Cloud Storage.</p> <p>All constructors will check for environment variables. Refer to <code>GCSConfig</code> for valid environment variables.</p> <p>If no credentials are explicitly provided, they will be sourced from the environment as documented here.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.client_options","title":"client_options  <code>property</code>","text":"<pre><code>client_options: ClientConfig | None\n</code></pre> <p>Get the store's client configuration.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.config","title":"config  <code>property</code>","text":"<pre><code>config: GCSConfig\n</code></pre> <p>Get the underlying GCS config parameters.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.credential_provider","title":"credential_provider  <code>property</code>","text":"<pre><code>credential_provider: GCSCredentialProvider | None\n</code></pre> <p>Get the store's credential provider.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str | None\n</code></pre> <p>Get the prefix applied to all operations in this store, if any.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.retry_config","title":"retry_config  <code>property</code>","text":"<pre><code>retry_config: RetryConfig | None\n</code></pre> <p>Get the store's retry configuration.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    bucket: str | None = None,\n    *,\n    prefix: str | None = None,\n    config: GCSConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: GCSCredentialProvider | None = None,\n    **kwargs: Unpack[GCSConfig],\n) -&gt; None\n</code></pre> <p>Construct a new GCSStore.</p> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The GCS bucket to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>A prefix within the bucket to use for all operations.</p> </li> <li> <code>config</code>               (<code>GCSConfig | None</code>)           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>GCSCredentialProvider | None</code>)           \u2013            <p>A callback to provide custom Google credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[GCSConfig]</code>)           \u2013            <p>GCS configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#async_tiff.store.GCSStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    prefix: str | None = None,\n    config: GCSConfig | None = None,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n    credential_provider: GCSCredentialProvider | None = None,\n    **kwargs: Unpack[GCSConfig],\n) -&gt; Self\n</code></pre> <p>Construct a new GCSStore with values populated from a well-known storage URL.</p> <p>Any path on the URL will be assigned as the <code>prefix</code> for the store. So if you pass <code>gs://&lt;bucket&gt;/path/to/directory</code>, the store will be created with a prefix of <code>path/to/directory</code>, and all further operations will use paths relative to that prefix.</p> <p>The supported url schemes are:</p> <ul> <li><code>gs://&lt;bucket&gt;/&lt;path&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>A prefix within the bucket to use for all operations.</p> </li> <li> <code>config</code>               (<code>GCSConfig | None</code>)           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> <li> <code>credential_provider</code>               (<code>GCSCredentialProvider | None</code>)           \u2013            <p>A callback to provide custom Google credentials.</p> </li> <li> <code>kwargs</code>               (<code>Unpack[GCSConfig]</code>)           \u2013            <p>GCS configuration values. Supports the same values as <code>config</code>, but as named keyword args.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig","title":"async_tiff.store.GCSConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration parameters for GCSStore.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import GCSConfig\n</code></pre>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig.application_credentials","title":"application_credentials  <code>instance-attribute</code>","text":"<pre><code>application_credentials: str\n</code></pre> <p>Application credentials path.</p> <p>See cloud.google.com/docs/authentication/provide-credentials-adc.</p> <p>Environment variable: <code>GOOGLE_APPLICATION_CREDENTIALS</code>.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig.bucket","title":"bucket  <code>instance-attribute</code>","text":"<pre><code>bucket: str\n</code></pre> <p>Bucket name. (required)</p> <p>Environment variables:</p> <ul> <li><code>GOOGLE_BUCKET</code></li> <li><code>GOOGLE_BUCKET_NAME</code></li> </ul>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig.service_account","title":"service_account  <code>instance-attribute</code>","text":"<pre><code>service_account: str\n</code></pre> <p>Path to the service account file.</p> <p>This or <code>service_account_key</code> must be set.</p> <p>Example value <code>\"/tmp/gcs.json\"</code>. Example contents of <code>gcs.json</code>:</p> <pre><code>{\n   \"gcs_base_url\": \"https://localhost:4443\",\n   \"disable_oauth\": true,\n   \"client_email\": \"\",\n   \"private_key\": \"\"\n}\n</code></pre> <p>Environment variables:</p> <ul> <li><code>GOOGLE_SERVICE_ACCOUNT</code></li> <li><code>GOOGLE_SERVICE_ACCOUNT_PATH</code></li> </ul>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig.service_account_key","title":"service_account_key  <code>instance-attribute</code>","text":"<pre><code>service_account_key: str\n</code></pre> <p>The serialized service account key.</p> <p>The service account must be in the JSON format. This or <code>with_service_account_path</code> must be set.</p> <p>Environment variable: <code>GOOGLE_SERVICE_ACCOUNT_KEY</code>.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSConfig.skip_signature","title":"skip_signature  <code>instance-attribute</code>","text":"<pre><code>skip_signature: bool\n</code></pre> <p>If <code>True</code>, GCSStore will not fetch credentials and will not sign requests.</p> <p>This can be useful when interacting with public GCS buckets that deny authorized requests.</p> <p>Environment variable: <code>GOOGLE_SKIP_SIGNATURE</code>.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSCredential","title":"async_tiff.store.GCSCredential","text":"<p>               Bases: <code>TypedDict</code></p> <p>A Google Cloud Storage Credential.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import GCSCredential\n</code></pre>"},{"location":"api/store/gcs/#async_tiff.store.GCSCredential.expires_at","title":"expires_at  <code>instance-attribute</code>","text":"<pre><code>expires_at: datetime | None\n</code></pre> <p>Expiry datetime of credential. The datetime should have time zone set.</p> <p>If None, the credential will never expire.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSCredential.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>An HTTP bearer token.</p>"},{"location":"api/store/gcs/#async_tiff.store.GCSCredentialProvider","title":"async_tiff.store.GCSCredentialProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>A type hint for a synchronous or asynchronous callback to provide custom Google Cloud Storage credentials.</p> <p>This should be passed into the <code>credential_provider</code> parameter of <code>GCSStore</code>.</p> <p>Not importable at runtime</p> <p>To use this type hint in your code, import it within a <code>TYPE_CHECKING</code> block:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from obstore.store import GCSCredentialProvider\n</code></pre>"},{"location":"api/store/gcs/#async_tiff.store.GCSCredentialProvider.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; GCSCredential | Coroutine[Any, Any, GCSCredential]\n</code></pre> <p>Return a <code>GCSCredential</code>.</p>"},{"location":"api/store/http/","title":"HTTP","text":""},{"location":"api/store/http/#async_tiff.store.HTTPStore","title":"async_tiff.store.HTTPStore","text":"<p>Configure a connection to a generic HTTP server.</p>"},{"location":"api/store/http/#async_tiff.store.HTTPStore.client_options","title":"client_options  <code>property</code>","text":"<pre><code>client_options: ClientConfig | None\n</code></pre> <p>Get the store's client configuration.</p>"},{"location":"api/store/http/#async_tiff.store.HTTPStore.retry_config","title":"retry_config  <code>property</code>","text":"<pre><code>retry_config: RetryConfig | None\n</code></pre> <p>Get the store's retry configuration.</p>"},{"location":"api/store/http/#async_tiff.store.HTTPStore.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>Get the base url of this store.</p>"},{"location":"api/store/http/#async_tiff.store.HTTPStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: str,\n    *,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n) -&gt; None\n</code></pre> <p>Construct a new HTTPStore from a URL.</p> <p>Any path on the URL will be assigned as the <code>prefix</code> for the store. So if you pass <code>https://example.com/path/to/directory</code>, the store will be created with a prefix of <code>path/to/directory</code>, and all further operations will use paths relative to that prefix.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The base URL to use for the store.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>client_options</code>               (<code>ClientConfig | None</code>)           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>)           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>HTTPStore</p> </li> </ul>"},{"location":"api/store/http/#async_tiff.store.HTTPStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    client_options: ClientConfig | None = None,\n    retry_config: RetryConfig | None = None,\n) -&gt; Self\n</code></pre> <p>Construct a new HTTPStore from a URL.</p> <p>This is an alias of <code>HTTPStore.__init__</code>.</p>"},{"location":"api/store/local/","title":"Local","text":""},{"location":"api/store/local/#async_tiff.store.LocalStore","title":"async_tiff.store.LocalStore","text":"<p>An ObjectStore interface to local filesystem storage.</p> <p>Can optionally be created with a directory prefix.</p> <pre><code>from pathlib import Path\n\nstore = LocalStore()\nstore = LocalStore(prefix=\"/path/to/directory\")\nstore = LocalStore(prefix=Path(\".\"))\n</code></pre>"},{"location":"api/store/local/#async_tiff.store.LocalStore.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: Path | None\n</code></pre> <p>Get the prefix applied to all operations in this store, if any.</p>"},{"location":"api/store/local/#async_tiff.store.LocalStore.__init__","title":"__init__","text":"<pre><code>__init__(\n    prefix: str | Path | None = None,\n    *,\n    automatic_cleanup: bool = False,\n    mkdir: bool = False,\n) -&gt; None\n</code></pre> <p>Create a new LocalStore.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Use the specified prefix applied to all paths. Defaults to <code>None</code>.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>automatic_cleanup</code>               (<code>bool</code>)           \u2013            <p>if <code>True</code>, enables automatic cleanup of empty directories when deleting files. Defaults to False.</p> </li> <li> <code>mkdir</code>               (<code>bool</code>)           \u2013            <p>if <code>True</code> and <code>prefix</code> is not <code>None</code>, the directory at <code>prefix</code> will attempt to be created. Note that this root directory will not be cleaned up, even if <code>automatic_cleanup</code> is <code>True</code>.</p> </li> </ul>"},{"location":"api/store/local/#async_tiff.store.LocalStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str, *, automatic_cleanup: bool = False, mkdir: bool = False\n) -&gt; Self\n</code></pre> <p>Construct a new LocalStore from a <code>file://</code> URL.</p> <p>Examples:</p> <p>Construct a new store pointing to the root of your filesystem: <pre><code>url = \"file:///\"\nstore = LocalStore.from_url(url)\n</code></pre></p> <p>Construct a new store with a directory prefix: <pre><code>url = \"file:///Users/kyle/\"\nstore = LocalStore.from_url(url)\n</code></pre></p>"},{"location":"api/store/memory/","title":"Memory","text":""},{"location":"api/store/memory/#async_tiff.store.MemoryStore","title":"async_tiff.store.MemoryStore","text":"<p>A fully in-memory implementation of ObjectStore.</p> <p>Create a new in-memory store: <pre><code>store = MemoryStore()\n</code></pre></p>"}]}